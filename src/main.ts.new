export type ShapeType = 'circle' | 'square' | 'rectangle' | 'triangle' | 'pentagon';

export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface DetectedShape {
  type: ShapeType;
  confidence: number;
  bbox: BoundingBox;
  vertices?: { x: number; y: number }[];
  center: { x: number; y: number };
  area: number;
}

export interface DetectionResult {
  shapes: DetectedShape[];
  processingTime: number;
}

class ShapeDetector {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private width: number = 0;
  private height: number = 0;
  private data: Uint8ClampedArray | null = null;
  private binaryMatrix: boolean[][] = [];
  private visited: boolean[][] = [];

  private isBrowserEnvironment(): boolean {
    return typeof window !== 'undefined' && 
           typeof document !== 'undefined' && 
           typeof document.addEventListener === 'function';
  }

  constructor() {
    // Initialize canvas elements
    this.canvas = document.createElement('canvas');
    
    // Set up context with type assertion
    const ctx = this.canvas.getContext('2d');
    
    if (!ctx) {
      throw new Error('Could not get 2D context for canvas');
    }
    
    this.ctx = ctx;
    
    // Only set up event listeners in browser environment
    if (this.isBrowserEnvironment()) {
      this.initializeEventListeners();
    }
  }

  private initializeEventListeners(): void {
    if (!this.isBrowserEnvironment()) return;
    
    const setup = () => {
      const imageInput = document.getElementById('imageInput') as HTMLInputElement | null;
      if (!imageInput) {
        console.warn('Image input element not found');
        return;
      }

      const handleFileChange = async (event: Event) => {
        const target = event.target as HTMLInputElement;
        const file = target.files?.[0];
        
        if (!file) return;
        
        try {
          await this.processImage(file);
        } catch (error) {
          console.error('Error processing image:', error);
          if (process.env.NODE_ENV !== 'test') {
            alert('Error processing image. Please try another image.');
          }
        }
      };

      // Remove any existing event listeners to prevent duplicates
      imageInput.removeEventListener('change', handleFileChange);
      imageInput.addEventListener('change', handleFileChange);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setup);
    } else {
      // If the document is already loaded, run setup immediately
      setTimeout(setup, 0);
    }
  }

  private async loadImage(file: File): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      if (!this.isBrowserEnvironment()) {
        reject(new Error('Not in browser environment'));
        return;
      }

      const img = new Image();
      const url = URL.createObjectURL(file);
      
      img.onload = () => {
        URL.revokeObjectURL(url);
        resolve(img);
      };
      
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load image'));
      };
      
      img.src = url;
    });
  }

  private getImageDataFromImage(img: HTMLImageElement): ImageData {
    if (!this.isBrowserEnvironment()) {
      throw new Error('Not in browser environment');
    }

    this.canvas.width = img.width;
    this.canvas.height = img.height;
    this.width = img.width;
    this.height = img.height;

    this.ctx.clearRect(0, 0, this.width, this.height);
    this.ctx.drawImage(img, 0, 0);

    // Initialize binary matrix and visited arrays
    this.binaryMatrix = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
    this.visited = Array(this.height).fill(null).map(() => Array(this.width).fill(false));

    return this.ctx.getImageData(0, 0, this.width, this.height);
  }

  private async processImage(file: File): Promise<void> {
    if (!this.isBrowserEnvironment()) {
      console.warn('Not in browser environment');
      return;
    }
    
    try {
      const img = await this.loadImage(file);
      const imageData = this.getImageDataFromImage(img);
      const result = await this.detectShapes(imageData);
      this.displayResults(result);
    } catch (error) {
      console.error('Error processing image:', error);
      if (this.isBrowserEnvironment() && process.env.NODE_ENV !== 'test') {
        alert('Error processing image. Please try another image.');
      }
    }
  }

  private displayResults(result: DetectionResult): void {
    if (!this.isBrowserEnvironment()) return;
    
    const resultsContainer = document.getElementById('results');
    if (!resultsContainer) {
      console.warn('Results container not found');
      return;
    }
    
    // Clear previous results
    resultsContainer.innerHTML = '';
    
    if (result.shapes.length === 0) {
      const noShapes = document.createElement('p');
      noShapes.className = 'no-shapes';
      noShapes.textContent = 'No shapes detected in the image.';
      resultsContainer.appendChild(noShapes);
      return;
    }
    
    // Display results
    const pre = document.createElement('pre');
    pre.textContent = JSON.stringify(result, null, 2);
    resultsContainer.appendChild(pre);
  }

  private async detectShapes(imageData: ImageData): Promise<DetectionResult> {
    const startTime = performance.now();
    const shapes: DetectedShape[] = [];

    // Store image data for processing
    this.data = imageData.data;
    this.width = imageData.width;
    this.height = imageData.height;

    // This is a placeholder - implement actual shape detection logic here
    // For now, we'll return a mock result
    if (this.width > 0 && this.height > 0) {
      shapes.push({
        type: 'rectangle',
        confidence: 0.95,
        bbox: { x: 0, y: 0, width: this.width, height: this.height },
        center: { x: this.width / 2, y: this.height / 2 },
        area: this.width * this.height,
        vertices: [
          { x: 0, y: 0 },
          { x: this.width, y: 0 },
          { x: this.width, y: this.height },
          { x: 0, y: this.height }
        ]
      });
    }

    const processingTime = performance.now() - startTime;

    return {
      shapes,
      processingTime
    };
  }
}

// Initialize the shape detector when the script loads
if (typeof window !== 'undefined') {
  window.addEventListener('DOMContentLoaded', () => {
    new ShapeDetector();
  });
}

export default ShapeDetector;
